<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Invaders Deluxe</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #050608;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 3px solid #444;
      background: #000;
      width: 480px;   /* 3x Skalierung */
      height: 360px;  /* 3x Skalierung */
      display: block;
    }

    #info {
      margin-top: 10px;
      font-size: 14px;
      text-align: center;
      color: #bbb;
    }

    #info strong {
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="game" width="160" height="120"></canvas>

  <div id="info">
    <strong>Controls:</strong> ← / → bewegen, <strong>Space</strong> schießen,
    <strong>Enter</strong> starten, <strong>R</strong> Restart, <strong>M</strong> Mute.
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const W = canvas.width;
    const H = canvas.height;

    const GAME_STATE = {
      MENU: "menu",
      PLAYING: "playing",
      GAMEOVER: "gameover",
    };

    let state = GAME_STATE.MENU;

    // Highscore
    let highScore = 0;
    try {
      const saved = localStorage.getItem("pixelInvadersHighScore");
      if (saved) highScore = parseInt(saved, 10) || 0;
    } catch (_) {
      highScore = 0;
    }

    // Audio
    let audioCtx = null;
    let muted = false;

    function initAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) audioCtx = new AC();
      }
    }

    function playSound(type) {
      if (muted) return;
      initAudio();
      if (!audioCtx) return;

      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      // Defaults
      osc.type = "square";
      let duration = 0.12;

      if (type === "laser") {
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + duration);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      } else if (type === "explosion") {
        osc.type = "sawtooth";
        duration = 0.25;
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + duration);
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      } else if (type === "hit") {
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + duration);
        gain.gain.setValueAtTime(0.35, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      } else if (type === "powerup") {
        osc.type = "triangle";
        duration = 0.25;
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + duration);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      } else if (type === "shieldBreak") {
        osc.type = "sawtooth";
        duration = 0.2;
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.linearRampToValueAtTime(150, now + duration);
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      }

      osc.start(now);
      osc.stop(now + duration);
    }

    // --- PLAYER ---
    const player = {
      x: W / 2 - 5,
      y: H - 16,
      w: 10,
      h: 10,
      speed: 1.6,
      lives: 3,
      invincibleUntil: 0,
    };

    // Upgrades
    const upgrades = {
      rapidUntil: 0,
      doubleUntil: 0,
      shieldUntil: 0,
    };

    // --- GAME DATA ---
    let level = 1;
    let score = 0;

    const bullets = [];       // player bullets
    const enemyBullets = [];  // enemy bullets
    const enemies = [];
    const particles = [];     // explosion particles
    const powerups = [];      // falling upgrades

    let enemyDx = 0.4;        // horizontal speed
    let enemyStepDown = 4;
    let lastEnemyMoveTime = 0;

    let enemyShootInterval = 1200; // ms
    let lastEnemyShotTime = 0;

    const keys = {};

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;

      if (e.key === "m" || e.key === "M") {
        muted = !muted;
        if (!muted) playSound("powerup");
      }

      if (state === GAME_STATE.MENU && (e.key === "Enter")) {
        startNewGame();
      }

      if (state === GAME_STATE.GAMEOVER && (e.key === "r" || e.key === "R" || e.key === "Enter")) {
        startNewGame();
      }

      if (state === GAME_STATE.PLAYING && (e.key === " " || e.code === "Space")) {
        shootPlayer();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    // --- INITIAL ENEMIES ---
    function initEnemiesForLevel() {
      enemies.length = 0;

      const enemyRows = 3 + Math.min(level - 1, 2); // 3–5 Reihen
      const enemyCols = 7;
      const enemySpacingX = 14;
      const enemySpacingY = 12;
      const enemyStartX = 10;
      const enemyStartY = 12;

      for (let row = 0; row < enemyRows; row++) {
        for (let col = 0; col < enemyCols; col++) {
          const x = enemyStartX + col * enemySpacingX;
          const y = enemyStartY + row * enemySpacingY;
          enemies.push({
            x,
            y,
            w: 9,
            h: 7,
            type: (row + col) % 2 === 0 ? "red" : "blue",
          });
        }
      }

      // Difficulty scaling
      enemyDx = 0.3 + level * 0.15;
      enemyShootInterval = Math.max(450, 1200 - (level - 1) * 120);
    }

    // --- POWERUPS ---
    function spawnPowerup(x, y) {
      const overallChance = 0.25; // 25% Chance überhaupt eins zu droppen
      if (Math.random() > overallChance) return;

      let type;
      const r = Math.random();
      if (r < 0.33) type = "rapid";
      else if (r < 0.66) type = "double";
      else type = "shield";

      powerups.push({
        x: x + 1,
        y: y,
        w: 6,
        h: 6,
        dy: 0.6,
        type,
      });
    }

    function applyPowerup(type, now) {
      if (type === "rapid") {
        upgrades.rapidUntil = now + 8000; // 8s
      } else if (type === "double") {
        upgrades.doubleUntil = now + 8000;
      } else if (type === "shield") {
        upgrades.shieldUntil = now + 10000; // 10s
      }
      playSound("powerup");
    }

    // --- EXPLOSIONS ---
    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 14; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.4 + 0.3;
        particles.push({
          x,
          y,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          life: 400, // ms
          age: 0,
          color,
        });
      }
    }

    // --- PLAYER SHOOT ---
    let lastPlayerShotTime = 0;
    const baseShootCooldown = 250;

    function getPlayerShootCooldown(now) {
      if (now < upgrades.rapidUntil) return baseShootCooldown * 0.4;
      return baseShootCooldown;
    }

    function shootPlayer() {
      const now = performance.now();
      const cooldown = getPlayerShootCooldown(now);
      if (now - lastPlayerShotTime < cooldown) return;

      const doubleShot = now < upgrades.doubleUntil;

      if (doubleShot) {
        bullets.push({
          x: player.x + 2,
          y: player.y - 3,
          w: 2,
          h: 4,
          dy: -2.8,
        });
        bullets.push({
          x: player.x + player.w - 4,
          y: player.y - 3,
          w: 2,
          h: 4,
          dy: -2.8,
        });
      } else {
        bullets.push({
          x: player.x + player.w / 2 - 1,
          y: player.y - 3,
          w: 2,
          h: 4,
          dy: -2.8,
        });
      }

      lastPlayerShotTime = now;
      playSound("laser");
    }

    // --- ENEMY SHOOT ---
    function enemyShoot() {
      if (enemies.length === 0) return;
      const now = performance.now();
      if (now - lastEnemyShotTime < enemyShootInterval) return;

      const bottomEnemiesByCol = {};
      for (const e of enemies) {
        const colKey = Math.round(e.x / 10);
        if (!bottomEnemiesByCol[colKey] || bottomEnemiesByCol[colKey].y < e.y) {
          bottomEnemiesByCol[colKey] = e;
        }
      }
      const bottomList = Object.values(bottomEnemiesByCol);
      const shooter = bottomList[Math.floor(Math.random() * bottomList.length)];
      if (!shooter) return;

      enemyBullets.push({
        x: shooter.x + shooter.w / 2 - 1,
        y: shooter.y + shooter.h,
        w: 2,
        h: 4,
        dy: 1.3 + level * 0.2,
      });

      lastEnemyShotTime = now;
    }

    // --- START/RESET ---
    function startNewGame() {
      score = 0;
      level = 1;
      player.lives = 3;
      player.x = W / 2 - player.w / 2;
      bullets.length = 0;
      enemyBullets.length = 0;
      particles.length = 0;
      powerups.length = 0;
      upgrades.rapidUntil = 0;
      upgrades.doubleUntil = 0;
      upgrades.shieldUntil = 0;
      initEnemiesForLevel();
      lastEnemyMoveTime = 0;
      lastEnemyShotTime = 0;
      lastTime = 0;
      state = GAME_STATE.PLAYING;
    }

    function startNextLevel() {
      level++;
      bullets.length = 0;
      enemyBullets.length = 0;
      particles.length = 0;
      powerups.length = 0;
      upgrades.rapidUntil = 0;
      upgrades.doubleUntil = 0;
      // Shield lassen wir, wenn es noch läuft
      initEnemiesForLevel();
      lastEnemyMoveTime = 0;
      lastEnemyShotTime = 0;
    }

    function gameOver() {
      state = GAME_STATE.GAMEOVER;
      playSound("explosion");
      if (score > highScore) {
        highScore = score;
        try {
          localStorage.setItem("pixelInvadersHighScore", String(highScore));
        } catch (_) { }
      }
    }

    // --- UPDATE ---
    let lastTime = 0;

    function update(dt) {
      if (state !== GAME_STATE.PLAYING) return;

      const now = performance.now();

      // Player movement
      if (keys["ArrowLeft"]) {
        player.x -= player.speed;
      }
      if (keys["ArrowRight"]) {
        player.x += player.speed;
      }
      if (player.x < 2) player.x = 2;
      if (player.x + player.w > W - 2) player.x = W - 2 - player.w;

      // Player bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y += b.dy;
        if (b.y + b.h < 0) {
          bullets.splice(i, 1);
        }
      }

      // Enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        eb.y += eb.dy;
        if (eb.y > H) {
          enemyBullets.splice(i, 1);
        }
      }

      // Enemies bewegen
      const moveNow = now;
      if (moveNow - lastEnemyMoveTime > 20) {
        let hitEdge = false;
        for (const e of enemies) {
          e.x += enemyDx;
          if (e.x <= 2 || e.x + e.w >= W - 2) {
            hitEdge = true;
          }
        }

        if (hitEdge) {
          enemyDx = -enemyDx;
          for (const e of enemies) {
            e.y += enemyStepDown;
            if (e.y + e.h >= player.y) {
              gameOver();
            }
          }
        }

        lastEnemyMoveTime = moveNow;
      }

      // Gegner schießen
      enemyShoot();

      // Bullet vs Enemy
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (
            b.x < e.x + e.w &&
            b.x + b.w > e.x &&
            b.y < e.y + e.h &&
            b.y + b.h > e.y
          ) {
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.type === "red" ? "#ff5252" : "#64b5f6");
            spawnPowerup(e.x, e.y);
            enemies.splice(j, 1);
            bullets.splice(i, 1);
            score += 10;
            playSound("explosion");
            hit = true;
            break;
          }
        }
        if (hit) continue;
      }

      // Enemy bullet vs Player
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        if (
          eb.x < player.x + player.w &&
          eb.x + eb.w > player.x &&
          eb.y < player.y + player.h &&
          eb.y + eb.h > player.y
        ) {
          enemyBullets.splice(i, 1);

          // Shield aktiv?
          if (now < upgrades.shieldUntil) {
            upgrades.shieldUntil = 0;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#80deea");
            playSound("shieldBreak");
            continue;
          }

          if (now > player.invincibleUntil) {
            player.lives--;
            player.invincibleUntil = now + 1500;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffb74d");
            playSound("hit");
            if (player.lives <= 0) {
              gameOver();
            }
          }
        }
      }

      // Powerups updaten
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += p.dy;
        if (p.y > H) {
          powerups.splice(i, 1);
          continue;
        }

        // Kollisionscheck mit Player
        if (
          p.x < player.x + player.w &&
          p.x + p.w > player.x &&
          p.y < player.y + player.h &&
          p.y + p.h > player.y
        ) {
          applyPowerup(p.type, now);
          powerups.splice(i, 1);
        }
      }

      // Explosion-Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx;
        p.y += p.dy;
        p.age += dt;
        // leichte "Gravitation"
        p.dy += 0.01;
        if (p.age > p.life) {
          particles.splice(i, 1);
        }
      }

      // Alle Gegner weg -> nächstes Level
      if (enemies.length === 0 && state === GAME_STATE.PLAYING) {
        startNextLevel();
      }
    }

    // --- DRAW HELPERS ---
    function drawPixelRect(x, y, w, h, color, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillRect(Math.round(x), Math.round(y), w, h);
      ctx.restore();
    }

    function drawPlayer() {
      const now = performance.now();
      const flashing = now < player.invincibleUntil && Math.floor(now / 100) % 2 === 0;

      // Shield Aura
      if (now < upgrades.shieldUntil) {
        drawPixelRect(player.x - 2, player.y - 2, player.w + 4, player.h + 4, "#80deea", 0.25);
      }

      if (flashing) return;

      // Körper (Anzug)
      drawPixelRect(player.x, player.y + 3, player.w, player.h - 3, "#777");
      // Kopf
      drawPixelRect(player.x + 3, player.y, 4, 3, "#f5d7b3");
      // Krawatte
      drawPixelRect(player.x + player.w / 2 - 1, player.y + 4, 2, 3, "#e53935");
      // Schultern
      drawPixelRect(player.x + 1, player.y + 3, player.w - 2, 2, "#888");
    }

    function drawEnemies() {
      for (const e of enemies) {
        const bodyColor = e.type === "red" ? "#d32f2f" : "#1976d2";
        const faceColor = "#ffeb3b";

        // Körper
        drawPixelRect(e.x, e.y + 3, e.w, e.h - 3, bodyColor);
        // Kopf
        drawPixelRect(e.x + 2, e.y, e.w - 4, 3, faceColor);
        // Augen
        drawPixelRect(e.x + 3, e.y + 1, 1, 1, "#000");
        drawPixelRect(e.x + e.w - 4, e.y + 1, 1, 1, "#000");
        // Arme
        drawPixelRect(e.x - 1, e.y + 4, 2, 2, bodyColor);
        drawPixelRect(e.x + e.w - 1, e.y + 4, 2, 2, bodyColor);
      }
    }

    function drawBullets() {
      for (const b of bullets) {
        drawPixelRect(b.x, b.y, b.w, b.h, "#fff");
      }
    }

    function drawEnemyBullets() {
      for (const eb of enemyBullets) {
        drawPixelRect(eb.x, eb.y, eb.w, eb.h, "#ffeb3b");
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = 1 - p.age / p.life;
        drawPixelRect(p.x, p.y, 2, 2, p.color, alpha);
      }
    }

    function drawPowerups() {
      for (const p of powerups) {
        let color = "#fff";
        if (p.type === "rapid") color = "#ff9800";
        else if (p.type === "double") color = "#ab47bc";
        else if (p.type === "shield") color = "#80deea";

        drawPixelRect(p.x, p.y, p.w, p.h, color);
      }
    }

    function drawHUD() {
      ctx.fillStyle = "#fff";
      ctx.font = "6px monospace";
      ctx.textAlign = "left";
      ctx.fillText("SCORE: " + score, 4, 8);
      ctx.fillText("LEVEL: " + level, 4, 16);

      // Lives
      ctx.fillText("LIVES:", 60, 8);
      for (let i = 0; i < player.lives; i++) {
        drawPixelRect(92 + i * 6, 3, 4, 4, "#e53935");
      }

      // Highscore & mute
      ctx.textAlign = "right";
      ctx.fillText("HI: " + highScore, W - 4, 8);
      ctx.fillText(muted ? "MUTE" : "SOUND", W - 4, 16);
      ctx.textAlign = "left";

      // Powerup-Status
      const now = performance.now();
      ctx.fillText("PWR:", 4, 24);

      if (now < upgrades.rapidUntil) {
        drawPixelRect(24, 20, 4, 4, "#ff9800");
      }
      if (now < upgrades.doubleUntil) {
        drawPixelRect(30, 20, 4, 4, "#ab47bc");
      }
      if (now < upgrades.shieldUntil) {
        drawPixelRect(36, 20, 4, 4, "#80deea");
      }
    }

    function drawMenu() {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "12px monospace";
      ctx.fillText("PIXEL INVADERS DELUXE", W / 2, 40);

      ctx.font = "6px monospace";
      ctx.fillText("← / → : move", W / 2, 60);
      ctx.fillText("SPACE : shoot", W / 2, 70);
      ctx.fillText("ENTER : start", W / 2, 80);
      ctx.fillText("M : mute/unmute", W / 2, 90);

      ctx.fillText("HIGH SCORE: " + highScore, W / 2, 105);

      ctx.textAlign = "left";
    }

    function drawGame() {
      ctx.clearRect(0, 0, W, H);
      drawEnemies();
      drawEnemyBullets();
      drawBullets();
      drawPowerups();
      drawPlayer();
      drawParticles();
      drawHUD();
    }

    function drawGameOverScreen() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "10px monospace";
      ctx.fillText("GAME OVER", W / 2, H / 2 - 10);

      ctx.font = "6px monospace";
      ctx.fillText("Score: " + score, W / 2, H / 2);
      ctx.fillText("Highscore: " + highScore, W / 2, H / 2 + 8);
      ctx.fillText("Press R or Enter", W / 2, H / 2 + 18);

      ctx.textAlign = "left";
    }

    // --- MAIN LOOP ---
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      if (state === GAME_STATE.MENU) {
        drawMenu();
      } else if (state === GAME_STATE.PLAYING) {
        update(dt);
        drawGame();
      } else if (state === GAME_STATE.GAMEOVER) {
        drawGame();
        drawGameOverScreen();
      }

      requestAnimationFrame(loop);
    }

    // Start mit Menü-Bildschirm
    initEnemiesForLevel();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
