<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Capitol Defender – Custom</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #050608;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 3px solid #444;
      background: #000;
      width: 1024px;
      height: 724px;
      display: block;
    }

    #info {
      margin-top: 10px;
      font-size: 14px;
      text-align: center;
      color: #bbb;
    }

    #info strong {
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1024" height="724"></canvas>

  <div id="info">
    <strong>Controls:</strong> ← / → bewegen, <strong>Space</strong> schießen,
    <strong>Enter</strong> starten, <strong>R</strong> Restart, <strong>M</strong> Mute.
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const W = canvas.width;
    const H = canvas.height;

    const GAME_STATE = {
      MENU: "menu",
      PLAYING: "playing",
      GAMEOVER: "gameover",
    };

    let state = GAME_STATE.MENU;

    // Highscore
    let highScore = 0;
    try {
      const saved = localStorage.getItem("pixelInvadersHighScore");
      if (saved) highScore = parseInt(saved, 10) || 0;
    } catch (_) {
      highScore = 0;
    }

    // --- IMAGES ---

    const playerImgNormal = new Image();
    playerImgNormal.src = "player_normal.png";

    const playerImgShoot = new Image();
    playerImgShoot.src = "player_shooting.png";

    const enemyImages = [];
    for (let i = 1; i <= 5; i++) {
      const img = new Image();
      img.src = "enemy" + i + ".png";
      enemyImages.push(img);
    }

    // Hintergrundbild
    const backgroundImg = new Image();
    backgroundImg.src = "background.png";

    // --- AUDIO ---

    const MUSIC_URL = "https://github.com/bavarian472/bavarian472.github.io/blob/main/music.mp3?raw=true";

    let audioCtx = null;
    let muted = false;
    let bgMusic = null;
    let musicBlocked = false;

    function initSfxAudio() {
      try {
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) audioCtx = new AC();
        }
      } catch (e) {
        audioCtx = null;
      }
    }

    function playSound(type) {
      if (muted) return;
      try {
        initSfxAudio();
        if (!audioCtx) return;

        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        let duration = 0.12;

        if (type === "laser") {
          // Gun-ähnlicher Knall
          duration = 0.09;
          osc.type = "square";
          osc.frequency.setValueAtTime(280, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + duration);
          gain.gain.setValueAtTime(0.6, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "explosion") {
          osc.type = "sawtooth";
          duration = 0.25;
          osc.frequency.setValueAtTime(120, now);
          osc.frequency.exponentialRampToValueAtTime(40, now + duration);
          gain.gain.setValueAtTime(0.4, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "hit") {
          osc.type = "square";
          osc.frequency.setValueAtTime(200, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + duration);
          gain.gain.setValueAtTime(0.35, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "powerup") {
          osc.type = "triangle";
          duration = 0.25;
          osc.frequency.setValueAtTime(300, now);
          osc.frequency.linearRampToValueAtTime(600, now + duration);
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "shieldBreak") {
          osc.type = "sawtooth";
          duration = 0.2;
          osc.frequency.setValueAtTime(500, now);
          osc.frequency.linearRampToValueAtTime(150, now + duration);
          gain.gain.setValueAtTime(0.4, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        }

        osc.start(now);
        osc.stop(now + duration);
      } catch (e) {}
    }

    function startBackgroundMusic() {
      try {
        if (!bgMusic) {
          bgMusic = new Audio(MUSIC_URL);
          bgMusic.loop = true;
          bgMusic.volume = 0.4;
        }
        if (muted) return;

        bgMusic.play().catch(err => {
          console.warn("Music autoplay blocked – will start after interaction", err);
          musicBlocked = true;
        });
      } catch (e) {
        console.error("Error starting music", e);
      }
    }

    function updateMusicMuteState() {
      if (!bgMusic) return;
      if (muted) {
        bgMusic.pause();
      } else {
        bgMusic.play().catch(err => {
          console.warn("Music play failed after unmute", err);
          musicBlocked = true;
        });
      }
    }

    function tryResumeMusic() {
      if (!musicBlocked || !bgMusic || muted) return;
      musicBlocked = false;
      bgMusic.play().catch(err => {
        console.warn("Music still blocked", err);
        musicBlocked = true;
      });
    }

    window.addEventListener("click", tryResumeMusic);
    window.addEventListener("keydown", tryResumeMusic);

    // --- PLAYER (größer, auf Enemy-Niveau) ---
    const player = {
      w: 40,
      h: 40,
      x: W / 2 - 20,
      y: H - 90,
      speed: 4,
      lives: 3,
      invincibleUntil: 0,
      shootingUntil: 0,
    };

    // Upgrades
    const upgrades = {
      rapidUntil: 0,
      doubleUntil: 0,
      shieldUntil: 0,
      pierceUntil: 0,
      spreadUntil: 0,
      scoreMultUntil: 0,
    };

    // --- GAME DATA ---
    let level = 1;
    let score = 0;

    const bullets = [];
    const enemyBullets = [];
    const enemies = [];
    const particles = [];
    const powerups = [];
    const popups = [];

    let enemyDx = 0.6;
    let enemyStepDown = 20;
    let lastEnemyMoveTime = 0;

    let enemyShootInterval = 1200;
    let lastEnemyShotTime = 0;

    const keys = {};

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;

      if (e.key === "m" || e.key === "M") {
        muted = !muted;
        updateMusicMuteState();
        if (!muted) playSound("powerup");
      }

      if (state === GAME_STATE.MENU && e.key === "Enter") {
        startNewGame();
      }

      if (state === GAME_STATE.GAMEOVER && (e.key === "r" || e.key === "R" || e.key === "Enter")) {
        startNewGame();
      }

      if (state === GAME_STATE.PLAYING && (e.key === " " || e.code === "Space")) {
        shootPlayer();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    // --- LEVEL-TEXTE ---
    const levelMessages = {
      1: { title: "LEVEL 1 – FIRST FILIBUSTER", subtitle: "Die erste Welle blauer Formulare rollt an." },
      2: { title: "LEVEL 2 – TAX STORM",        subtitle: "Neue Abgaben, noch mehr Akten – halte dagegen." },
      3: { title: "LEVEL 3 – REGULATION FLOOD", subtitle: "Die Bürokratie flutet das Capitol." },
      4: { title: "LEVEL 4 – COMMITTEE CHAOS",  subtitle: "Sitzungen endlos, Geduld nicht." },
      5: { title: "LEVEL 5 – SWAMP BOSS",       subtitle: "Der Sumpf wirft alles, was er hat." }
    };

    function addPopup(title, subtitle, life = 2500) {
      popups.push({ title, subtitle, age: 0, life });
    }

    function showLevelPopup() {
      const msg = levelMessages[level] || {
        title: "LEVEL " + level,
        subtitle: "Die Bürokratie wird dichter."
      };
      addPopup(msg.title, msg.subtitle, 2600);
    }

    // --- ENEMIES ---
    function initEnemiesForLevel() {
      enemies.length = 0;

      const enemyRows = 3 + Math.min(level - 1, 2);
      const enemyCols = 9;
      const enemySpacingX = 80;
      const enemySpacingY = 60;
      const enemyStartX = 80;
      const enemyStartY = 80;

      for (let row = 0; row < enemyRows; row++) {
        for (let col = 0; col < enemyCols; col++) {
          const x = enemyStartX + col * enemySpacingX;
          const y = enemyStartY + row * enemySpacingY;
          enemies.push({
            x,
            y,
            w: 40,
            h: 40,
            spriteIndex: Math.floor(Math.random() * enemyImages.length),
          });
        }
      }

      enemyDx = 0.5 + level * 0.2;
      enemyShootInterval = Math.max(450, 1200 - (level - 1) * 120);
    }

    // --- POWERUPS (seltener) ---
    function spawnPowerup(x, y) {
      const overallChance = 0.12;
      if (Math.random() > overallChance) return;

      let type;
      const r = Math.random();
      if (r < 0.2) type = "rapid";
      else if (r < 0.4) type = "double";
      else if (r < 0.55) type = "shield";
      else if (r < 0.7) type = "pierce";
      else if (r < 0.85) type = "spread";
      else if (r < 0.95) type = "score";
      else type = "life";

      powerups.push({
        x: x + 8,
        y,
        w: 16,
        h: 16,
        dy: 1.2,
        type,
      });
    }

    function applyPowerup(type, now) {
      if (type === "rapid") {
        upgrades.rapidUntil = now + 8000;
        addPopup("Power-up: Rapid Fire", "Signifikant höhere Feuerrate.", 1800);
      } else if (type === "double") {
        upgrades.doubleUntil = now + 8000;
        addPopup("Power-up: Double Shot", "Zwei Schüsse gleichzeitig.", 1800);
      } else if (type === "shield") {
        upgrades.shieldUntil = now + 10000;
        addPopup("Power-up: Shield", "Ein Treffer wird komplett geblockt.", 1800);
      } else if (type === "pierce") {
        upgrades.pierceUntil = now + 8000;
        addPopup("Power-up: Pierce Shot", "Schüsse durchschlagen Gegner.", 1800);
      } else if (type === "spread") {
        upgrades.spreadUntil = now + 8000;
        addPopup("Power-up: Spread Shot", "Dreifacher Streuschuss.", 1800);
      } else if (type === "score") {
        upgrades.scoreMultUntil = now + 10000;
        addPopup("Power-up: Score Boost", "Doppelter Score für Abschüsse.", 1800);
      } else if (type === "life") {
        if (player.lives < 8) {
          player.lives++;
          addPopup("Extra Life", "Ein zusätzliches Leben.", 1800);
        } else {
          score += 50;
          addPopup("Bonus Score", "+50 Punkte statt Leben.", 1800);
        }
      }
      playSound("powerup");
    }

    // --- EXPLOSIONS ---
    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 0.5;
        particles.push({
          x,
          y,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          life: 600,
          age: 0,
          color,
        });
      }
    }

    // --- PLAYER SHOOT ---
    let lastPlayerShotTime = 0;
    const baseShootCooldown = 230;

    function getPlayerShootCooldown(now) {
      if (now < upgrades.rapidUntil) return baseShootCooldown * 0.4;
      return baseShootCooldown;
    }

    function shootPlayer() {
      const now = performance.now();
      const cooldown = getPlayerShootCooldown(now);
      if (now - lastPlayerShotTime < cooldown) return;

      const doubleShot = now < upgrades.doubleUntil;
      const spreadShot = now < upgrades.spreadUntil;

      player.shootingUntil = now + 150;

      const bulletWidth = 4;
      const bulletHeight = 14;
      const baseX = player.x + player.w / 2 - bulletWidth / 2;
      const startY = player.y - 6;

      if (spreadShot) {
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: 0,    dy: -6 });
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: -1.6, dy: -5.2 });
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: 1.6,  dy: -5.2 });
      } else if (doubleShot) {
        bullets.push({ x: player.x + 6,               y: startY, w: bulletWidth, h: bulletHeight, dx: 0, dy: -6 });
        bullets.push({ x: player.x + player.w - 10,   y: startY, w: bulletWidth, h: bulletHeight, dx: 0, dy: -6 });
      } else {
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: 0, dy: -6 });
      }

      lastPlayerShotTime = now;
      playSound("laser");
    }

    // --- ENEMY SHOOT ---
    function enemyShoot() {
      if (enemies.length === 0) return;
      const now = performance.now();
      if (now - lastEnemyShotTime < enemyShootInterval) return;

      const bottomEnemiesByCol = {};
      for (const e of enemies) {
        const colKey = Math.round(e.x / 80);
        if (!bottomEnemiesByCol[colKey] || bottomEnemiesByCol[colKey].y < e.y) {
          bottomEnemiesByCol[colKey] = e;
        }
      }
      const bottomList = Object.values(bottomEnemiesByCol);
      const shooter = bottomList[Math.floor(Math.random() * bottomList.length)];
      if (!shooter) return;

      enemyBullets.push({
        x: shooter.x + shooter.w / 2 - 2,
        y: shooter.y + shooter.h,
        w: 4,
        h: 14,
        dx: 0,
        dy: 3 + level * 0.3,
      });

      lastEnemyShotTime = now;
    }

    // --- START/RESET ---
    function startNewGame() {
      score = 0;
      level = 1;
      player.lives = 3;
      player.x = W / 2 - player.w / 2;
      bullets.length = 0;
      enemyBullets.length = 0;
      particles.length = 0;
      powerups.length = 0;
      popups.length = 0;
      upgrades.rapidUntil = 0;
      upgrades.doubleUntil = 0;
      upgrades.shieldUntil = 0;
      upgrades.pierceUntil = 0;
      upgrades.spreadUntil = 0;
      upgrades.scoreMultUntil = 0;
      initEnemiesForLevel();
      lastEnemyMoveTime = 0;
      lastEnemyShotTime = 0;
      lastTime = 0;
      state = GAME_STATE.PLAYING;
      showLevelPopup();
      startBackgroundMusic();
    }

    function startNextLevel() {
      level++;
      bullets.length = 0;
      enemyBullets.length = 0;
      particles.length = 0;
      powerups.length = 0;
      initEnemiesForLevel();
      lastEnemyMoveTime = 0;
      lastEnemyShotTime = 0;
      showLevelPopup();
    }

    function gameOver() {
      state = GAME_STATE.GAMEOVER;
      playSound("explosion");
      addPopup("Capitol verloren.", "Die Bürokratie war diesmal stärker.", 2600);
      if (score > highScore) {
        highScore = score;
        try {
          localStorage.setItem("pixelInvadersHighScore", String(highScore));
        } catch (_) {}
      }
    }

    // --- UPDATE ---
    let lastTime = 0;

    function update(dt) {
      if (state !== GAME_STATE.PLAYING) {
        updatePopups(dt);
        return;
      }

      const now = performance.now();

      if (keys["ArrowLeft"])  player.x -= player.speed;
      if (keys["ArrowRight"]) player.x += player.speed;
      if (player.x < 16) player.x = 16;
      if (player.x + player.w > W - 16) player.x = W - 16 - player.w;

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.dx || 0;
        b.y += b.dy;
        if (b.y + b.h < 0 || b.x < -40 || b.x > W + 40) {
          bullets.splice(i, 1);
        }
      }

      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        eb.x += eb.dx || 0;
        eb.y += eb.dy;
        if (eb.y > H + 40) {
          enemyBullets.splice(i, 1);
        }
      }

      const moveNow = now;
      if (moveNow - lastEnemyMoveTime > 20) {
        let hitEdge = false;
        for (const e of enemies) {
          e.x += enemyDx;
          if (e.x <= 16 || e.x + e.w >= W - 16) {
            hitEdge = true;
          }
        }

        if (hitEdge) {
          enemyDx = -enemyDx;
          for (const e of enemies) {
            e.y += enemyStepDown;
            if (e.y + e.h >= player.y) {
              gameOver();
            }
          }
        }

        lastEnemyMoveTime = moveNow;
      }

      enemyShoot();

      // Bullet vs Enemy
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (
            b.x < e.x + e.w &&
            b.x + b.w > e.x &&
            b.y < e.y + e.h &&
            b.y + b.h > e.y
          ) {
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#64b5f6");
            spawnPowerup(e.x, e.y);
            enemies.splice(j, 1);

            const mult = now < upgrades.scoreMultUntil ? 2 : 1;
            score += 10 * mult;

            playSound("explosion");
            hit = true;

            const piercing = now < upgrades.pierceUntil;
            if (!piercing) {
              bullets.splice(i, 1);
            }
            break;
          }
        }
        if (hit && i >= bullets.length) continue;
      }

      // Enemy bullet vs Player
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        if (
          eb.x < player.x + player.w &&
          eb.x + eb.w > player.x &&
          eb.y < player.y + player.h &&
          eb.y + eb.h > player.y
        ) {
          enemyBullets.splice(i, 1);

          if (now < upgrades.shieldUntil) {
            upgrades.shieldUntil = 0;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#80deea");
            playSound("shieldBreak");
            continue;
          }

          if (now > player.invincibleUntil) {
            player.lives--;
            player.invincibleUntil = now + 1500;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffb74d");
            playSound("hit");
            if (player.lives <= 0) {
              gameOver();
            }
          }
        }
      }

      // Powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += p.dy;
        if (p.y > H + 20) {
          powerups.splice(i, 1);
          continue;
        }

        if (
          p.x < player.x + player.w &&
          p.x + p.w > player.x &&
          p.y < player.y + player.h &&
          p.y + p.h > player.y
        ) {
          applyPowerup(p.type, now);
          powerups.splice(i, 1);
        }
      }

      // Explosion-Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx;
        p.y += p.dy;
        p.age += dt;
        p.dy += 0.02;
        if (p.age > p.life) {
          particles.splice(i, 1);
        }
      }

      updatePopups(dt);

      if (enemies.length === 0 && state === GAME_STATE.PLAYING) {
        startNextLevel();
      }
    }

    function updatePopups(dt) {
      for (let i = popups.length - 1; i >= 0; i--) {
        popups[i].age += dt;
        if (popups[i].age > popups[i].life) {
          popups.splice(i, 1);
        }
      }
    }

    // --- DRAW ---

    function drawBackground() {
      if (backgroundImg.complete && backgroundImg.naturalWidth > 0) {
        ctx.drawImage(backgroundImg, 0, 0, W, H);
      } else {
        ctx.fillStyle = "#020816";
        ctx.fillRect(0, 0, W, H);
      }
    }

    function drawPixelRect(x, y, w, h, color, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillRect(Math.round(x), Math.round(y), w, h);
      ctx.restore();
    }

    function drawPlayer() {
      const now = performance.now();
      const flashing = now < player.invincibleUntil && Math.floor(now / 100) % 2 === 0;

      if (now < upgrades.shieldUntil) {
        drawPixelRect(player.x - 6, player.y - 6, player.w + 12, player.h + 12, "#80deea", 0.25);
      }

      if (flashing) return;

      const isShooting = now < player.shootingUntil;
      const img = isShooting ? playerImgShoot : playerImgNormal;

      if (img && img.complete) {
        ctx.drawImage(img, Math.round(player.x), Math.round(player.y), player.w, player.h);
      } else {
        drawPixelRect(player.x, player.y + 8, player.w, player.h - 8, "#b71c1c");
        drawPixelRect(player.x + 10, player.y, 20, 8, "#f5d7b3");
        drawPixelRect(player.x + player.w / 2 - 1, player.y + 10, 2, 8, "#ff5252");
      }
    }

    function drawEnemies() {
      for (const e of enemies) {
        const img = enemyImages[e.spriteIndex] || null;
        if (img && img.complete) {
          ctx.drawImage(img, Math.round(e.x), Math.round(e.y), e.w, e.h);
        } else {
          const bodyColor = "#1976d2";
          const faceColor = "#ffeb3b";
          drawPixelRect(e.x, e.y + 10, e.w, e.h - 10, bodyColor);
          drawPixelRect(e.x + 6, e.y, e.w - 12, 10, faceColor);
        }
      }
    }

    function drawBullets() {
      for (const b of bullets) {
        drawPixelRect(b.x, b.y, b.w, b.h, "#fff");
      }
    }

    function drawEnemyBullets() {
      for (const eb of enemyBullets) {
        drawPixelRect(eb.x, eb.y, eb.w, eb.h, "#ffeb3b");
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = 1 - p.age / p.life;
        drawPixelRect(p.x, p.y, 3, 3, p.color, alpha);
      }
    }

    function drawPowerups() {
      for (const p of powerups) {
        let color = "#fff";
        if (p.type === "rapid") color = "#ff9800";
        else if (p.type === "double") color = "#ab47bc";
        else if (p.type === "shield") color = "#80deea";
        else if (p.type === "pierce") color = "#8bc34a";
        else if (p.type === "spread") color = "#ec407a";
        else if (p.type === "score") color = "#ffc107";
        else if (p.type === "life") color = "#ef5350";

        drawPixelRect(p.x, p.y, p.w, p.h, color);
      }
    }

    function drawHUD() {
      ctx.fillStyle = "#fff";
      ctx.font = "16px monospace";
      ctx.textAlign = "left";
      ctx.fillText("SCORE: " + score, 16, 26);
      ctx.fillText("LEVEL: " + level, 16, 48);

      ctx.fillText("LIVES:", 200, 26);
      for (let i = 0; i < player.lives; i++) {
        drawPixelRect(270 + i * 14, 18, 10, 10, "#e53935");
      }

      ctx.fillText("SIDE: RED", 16, 70);

      ctx.textAlign = "right";
      ctx.fillText("HI: " + highScore, W - 16, 26);
      ctx.fillText(muted ? "MUTE" : "SOUND", W - 16, 48);
      ctx.textAlign = "left";

      const now = performance.now();
      ctx.fillText("PWR:", 16, 94);

      let iconIndex = 0;
      function icon(active, color) {
        if (!active) return;
        drawPixelRect(74 + iconIndex * 14, 86, 12, 12, color);
        iconIndex++;
      }

      icon(now < upgrades.rapidUntil, "#ff9800");
      icon(now < upgrades.doubleUntil, "#ab47bc");
      icon(now < upgrades.shieldUntil, "#80deea");
      icon(now < upgrades.pierceUntil, "#8bc34a");
      icon(now < upgrades.spreadUntil, "#ec407a");
      icon(now < upgrades.scoreMultUntil, "#ffc107");
    }

    function drawPopups() {
      if (!popups.length) return;
      const p = popups[0];

      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(W / 2 - 160, H / 2 - 50, 320, 100);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "20px monospace";
      ctx.fillText(p.title, W / 2, H / 2 - 10);

      if (p.subtitle) {
        ctx.font = "13px monospace";
        ctx.fillText(p.subtitle, W / 2, H / 2 + 18);
      }

      ctx.textAlign = "left";
      ctx.restore();
    }

    function drawMenu() {
      drawBackground();

      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(0, 120, W, 260);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "32px monospace";
      ctx.fillText("CAPITOL DEFENDER", W / 2, 170);

      ctx.font = "18px monospace";
      ctx.fillText("Du spielst den roten Reformer,", W / 2, 210);
      ctx.fillText("der blaue Bürokratie-Blöcke stoppt.", W / 2, 235);

      ctx.fillText("← / → : bewegen", W / 2, 270);
      ctx.fillText("SPACE : schießen", W / 2, 295);
      ctx.fillText("ENTER : Start", W / 2, 320);
      ctx.fillText("M : Mute / Unmute", W / 2, 345);

      ctx.fillText("HIGH SCORE: " + highScore, W / 2, 380);

      ctx.textAlign = "left";
    }

    function drawGame() {
      drawBackground();
      drawEnemies();
      drawEnemyBullets();
      drawBullets();
      drawPowerups();
      drawPlayer();
      drawParticles();
      drawHUD();
      drawPopups();
    }

    function drawGameOverScreen() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(W / 2 - 180, H / 2 - 60, 360, 120);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "28px monospace";
      ctx.fillText("GAME OVER", W / 2, H / 2 - 10);

      ctx.font = "18px monospace";
      ctx.fillText("Score: " + score, W / 2, H / 2 + 15);
      ctx.fillText("Highscore: " + highScore, W / 2, H / 2 + 35);
      ctx.fillText("Press R or Enter", W / 2, H / 2 + 55);

      ctx.textAlign = "left";
    }

    // --- MAIN LOOP ---
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      if (state === GAME_STATE.MENU) {
        drawMenu();
        updatePopups(dt);
      } else if (state === GAME_STATE.PLAYING) {
        update(dt);
        drawGame();
      } else if (state === GAME_STATE.GAMEOVER) {
        updatePopups(dt);
        drawGame();
        drawGameOverScreen();
      }

      requestAnimationFrame(loop);
    }

    // Start
    initEnemiesForLevel();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
