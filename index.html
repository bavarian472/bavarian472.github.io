<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Capitol Defender</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #050608;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    #game-wrapper {
      position: relative;
      width: 1024px;
      height: 724px;
    }

    #bgImage {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    #flagGif {
      position: absolute;
      width: 42px;
      left: 53%;
      transform: translateX(-50%);
      top: 328px;
      z-index: 1;
      pointer-events: none;
    }

    canvas {
      position: relative;
      z-index: 2;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 3px solid #444;
      background: transparent;
      width: 1024px;
      height: 724px;
      display: block;
      cursor: pointer;
    }

    /* Hannity TV overlay */
    #news-tv {
      position: absolute;
      bottom: 40px;
      left: -380px;          /* off-screen start */
      width: 360px;
      height: 160px;
      background: #111;
      border: 4px solid #555;
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: space-between;
      opacity: 0;
      transition: all 0.8s ease-in-out;
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.8);
      z-index: 3;            /* above canvas */
    }

    #news-tv.show {
      left: 30px;            /* slide in */
      opacity: 1;
    }

    #tv-host {
      width: 130px;
      height: 100%;
      object-fit: cover;
      filter: contrast(1.1) brightness(1.05);
    }

    #tv-text {
      flex: 1;
      font-size: 14px;
      color: #f8f8f8;
      padding: 10px 12px;
      font-family: monospace;
      text-shadow: 1px 1px #000;
      line-height: 1.3;
    }

    #tv-text span.tag {
      display: inline-block;
      padding: 1px 5px;
      margin-bottom: 4px;
      background: #c62828;
      color: #fff;
      font-size: 11px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #info {
      margin-top: 10px;
      font-size: 14px;
      text-align: center;
      color: #bbb;
    }

    #info strong {
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="game-wrapper">
    <img id="bgImage" src="background.png" alt="Background">
    <img id="flagGif" src="flag.gif" alt="US Flag">
    <canvas id="game" width="1024" height="724"></canvas>

    <!-- Hannity TV overlay -->
    <div id="news-tv">
      <img src="hannity.png" id="tv-host" alt="Sean Hannity">
      <div id="tv-text">
        <span class="tag">FOX NEWS</span><br>
        Sean Hannity: …
      </div>
    </div>
  </div>

  <div id="info">
    <strong>Controls:</strong> ← / → move, <strong>Space</strong> shoot,
    <strong>Enter</strong> start, <strong>R</strong> restart, <strong>M</strong> mute.
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const W = 1024;
    const H = 724;
    const HUD_BAR_HEIGHT = 80;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.scale(dpr, dpr);

    const GAME_STATE = {
      MENU: "menu",
      PLAYING: "playing",
      GAMEOVER: "gameover",
    };

    let state = GAME_STATE.MENU;

    let highScore = 0;
    try {
      const saved = localStorage.getItem("pixelInvadersHighScore");
      if (saved) highScore = parseInt(saved, 10) || 0;
    } catch (_) {
      highScore = 0;
    }

    // Ticker messages
    const tickerMessages = [
      "NEWS: Paperwork wave approaching the Capitol...",
      "REPORT: Red reformer holds the line against bureaucracy.",
      "UPDATE: Blue paperwork units regroup for another assault.",
      "BRIEFING: Power-ups reported near the Capitol steps.",
      "ALERT: Diving envoys detected in the upper chamber."
    ];
    let tickerIndex = 0;
    let tickerTimer = 0;
    const TICKER_INTERVAL = 7000;

    function updateTicker(dt) {
      tickerTimer += dt;
      if (tickerTimer >= TICKER_INTERVAL) {
        tickerTimer = 0;
        tickerIndex = (tickerIndex + 1) % tickerMessages.length;
      }
    }

    // IMAGES
    const playerImgNormal = new Image();
    playerImgNormal.src = "player_normal.png";

    const playerImgShoot = new Image();
    playerImgShoot.src = "player_shooting.png";

    const enemyImages = [];
    for (let i = 1; i <= 5; i++) {
      const img = new Image();
      img.src = "enemy" + i + ".png";
      enemyImages.push(img);
    }

    const logoImg = new Image();
    logoImg.src = "logo.png";

    const backgroundImg = new Image();
    backgroundImg.src = "background.png";

    const heartImg = new Image();
    heartImg.src = "hearts.png";

    // Hannity TV elements
    const newsTv = document.getElementById("news-tv");
    const tvText = document.getElementById("tv-text");

    // AUDIO
    const MUSIC_URL =
      "https://github.com/bavarian472/bavarian472.github.io/blob/main/music.mp3?raw=true";

    let audioCtx = null;
    let muted = false;
    let bgMusic = null;
    let musicBlocked = false;

    const hannityAudio = new Audio("hannity.mp3");

    function initSfxAudio() {
      try {
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) audioCtx = new AC();
        }
      } catch (e) {
        audioCtx = null;
      }
    }

    function playSound(type) {
      if (muted) return;
      try {
        initSfxAudio();
        if (!audioCtx) return;

        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        let duration = 0.12;

        if (type === "laser") {
          duration = 0.09;
          osc.type = "square";
          osc.frequency.setValueAtTime(280, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + duration);
          gain.gain.setValueAtTime(0.6, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "explosion") {
          osc.type = "sawtooth";
          duration = 0.25;
          osc.frequency.setValueAtTime(120, now);
          osc.frequency.exponentialRampToValueAtTime(40, now + duration);
          gain.gain.setValueAtTime(0.4, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "hit") {
          osc.type = "square";
          osc.frequency.setValueAtTime(200, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + duration);
          gain.gain.setValueAtTime(0.35, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "powerup") {
          osc.type = "triangle";
          duration = 0.25;
          osc.frequency.setValueAtTime(300, now);
          osc.frequency.linearRampToValueAtTime(600, now + duration);
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        } else if (type === "shieldBreak") {
          osc.type = "sawtooth";
          duration = 0.2;
          osc.frequency.setValueAtTime(500, now);
          osc.frequency.linearRampToValueAtTime(150, now + duration);
          gain.gain.setValueAtTime(0.4, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        }

        osc.start(now);
        osc.stop(now + duration);
      } catch (e) {}
    }

    function startBackgroundMusic() {
      try {
        if (!bgMusic) {
          bgMusic = new Audio(MUSIC_URL);
          bgMusic.loop = true;
          bgMusic.volume = 0.4;
        }
        if (muted) return;

        bgMusic.play().catch(() => {
          musicBlocked = true;
        });
      } catch (e) {
        console.error("Error starting music", e);
      }
    }

    function updateMusicMuteState() {
      if (!bgMusic) return;
      if (muted) {
        bgMusic.pause();
      } else {
        bgMusic.play().catch(() => {
          musicBlocked = true;
        });
      }
    }

    function tryResumeMusic() {
      if (!musicBlocked || !bgMusic || muted) return;
      musicBlocked = false;
      bgMusic.play().catch(() => {
        musicBlocked = true;
      });
    }

    window.addEventListener("click", tryResumeMusic);
    window.addEventListener("keydown", tryResumeMusic);

    // PLAYER
    const player = {
      w: 52,
      h: 52,
      x: W / 2 - 26,
      y: H - 130,
      speed: 4,
      lives: 3,
      invincibleUntil: 0,
      shootingUntil: 0,
    };

    const upgrades = {
      rapidUntil: 0,
      doubleUntil: 0,
      shieldUntil: 0,
      pierceUntil: 0,
      spreadUntil: 0,
      scoreMultUntil: 0,
    };

    let level = 1;
    let score = 0;

    const bullets = [];
    const enemyBullets = [];
    const enemies = [];
    const particles = [];
    const powerups = [];
    const popups = [];

    let enemyDx = 0.6;
    let enemyStepDown = 24;
    let lastEnemyMoveTime = 0;
    let formationOffsetX = 0;
    let formationOffsetY = 0;
    let formationDir = 1;
    let formationType = 0;

    let enemyShootInterval = 1200;
    let lastEnemyShotTime = 0;

    let lastDiveTime = 0;

    let totalEnemiesThisLevel = 0;

    // Combo / killstreak
    const COMBO_WINDOW = 2500; // ms
    let comboCount = 0;
    let comboTimer = 0;

    // Weapon heat (visual only)
    let weaponHeat = 0; // 0..1

    const keys = {};

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;

      if (e.key === "m" || e.key === "M") {
        muted = !muted;
        updateMusicMuteState();
        if (!muted) playSound("powerup");
      }

      if (state === GAME_STATE.MENU && e.key === "Enter") {
        startNewGame();
      }

      if (state === GAME_STATE.GAMEOVER && (e.key === "r" || e.key === "R" || e.key === "Enter")) {
        startNewGame();
      }

      if (state === GAME_STATE.PLAYING && (e.key === " " || e.code === "Space")) {
        shootPlayer();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    canvas.addEventListener("click", (e) => {
      if (state !== GAME_STATE.MENU) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const logoW = 500;
      const aspect = logoImg.naturalWidth / (logoImg.naturalHeight || 1);
      const logoH = logoW / (aspect || 2);
      const logoX = W / 2 - logoW / 2;
      const logoY = H / 2 - logoH / 2 - 40;

      if (
        mouseX >= logoX &&
        mouseX <= logoX + logoW &&
        mouseY >= logoY &&
        mouseY <= logoY + logoH
      ) {
        startNewGame();
      }
    });

    const levelMessages = {
      1: { title: "LEVEL 1 – FIRST FILIBUSTER", subtitle: "The first wave of blue paperwork is incoming." },
      2: { title: "LEVEL 2 – TAX STORM",        subtitle: "New taxes, more files – hold the line." },
      3: { title: "LEVEL 3 – REGULATION FLOOD", subtitle: "Bureaucracy floods the Capitol." },
      4: { title: "LEVEL 4 – COMMITTEE CHAOS",  subtitle: "Endless hearings, no patience." },
      5: { title: "LEVEL 5 – SWAMP BOSS",       subtitle: "The swamp throws everything it has." }
    };

    function addPopup(title, subtitle, life = 2500) {
      popups.push({ title, subtitle, age: 0, life });
    }

    function showLevelPopup() {
      const msg = levelMessages[level] || {
        title: "LEVEL " + level,
        subtitle: "Bureaucracy grows thicker."
      };
      addPopup(msg.title, msg.subtitle, 2600);
    }

    // Hannity TV logic
    function showHannityNews(completedLevel) {
      if (completedLevel <= 0) return;
      const lines = [
        "Sean Hannity: The Capitol has been secured once again by our brave defender.",
        "Sean Hannity: Blue forces retreat as paperwork piles vanish.",
        "Sean Hannity: Bureaucracy beaten back by American strength.",
        "Sean Hannity: Another wave of nonsense defeated, folks.",
        "Sean Hannity: Incredible stand at the Capitol. On to the next one."
      ];
      const idx = (completedLevel - 1) % lines.length;
      tvText.innerHTML =
        '<span class="tag">FOX NEWS</span><br>' +
        lines[idx];

      newsTv.classList.add("show");

      if (!muted) {
        hannityAudio.currentTime = 0;
        hannityAudio.play().catch(() => {});
      }

      setTimeout(() => {
        newsTv.classList.remove("show");
      }, 6000);
    }

    function initEnemiesForLevel() {
      enemies.length = 0;

      const enemyRows = 3 + Math.min(level - 1, 2);
      const enemyCols = 9;
      const enemyW = 52;
      const enemyH = 52;
      const enemySpacingX = 90;
      const enemySpacingY = 70;
      const enemyStartX = 70;
      const enemyStartY = 120;

      for (let row = 0; row < enemyRows; row++) {
        for (let col = 0; col < enemyCols; col++) {
          const x = enemyStartX + col * enemySpacingX;
          const y = enemyStartY + row * enemySpacingY;
          enemies.push({
            baseX: x,
            baseY: y,
            x,
            y,
            w: enemyW,
            h: enemyH,
            row,
            col,
            spriteIndex: Math.floor(Math.random() * enemyImages.length),
            isDiving: false,
            vx: 0,
            vy: 0,
            diveSpeedY: 0
          });
        }
      }

      totalEnemiesThisLevel = enemies.length;

      formationOffsetX = 0;
      formationOffsetY = 0;
      formationDir = 1;
      enemyDx = 0.5 + level * 0.2;
      enemyShootInterval = Math.max(450, 1200 - (level - 1) * 120);
      formationType = (level - 1) % 3;
      lastDiveTime = 0;
    }

    function getFormationOffsets(row, col, t) {
      let ox = 0;
      let oy = 0;

      if (formationType === 0) {
        ox = 0;
        oy = 0;
      } else if (formationType === 1) {
        const amp = 12;
        const speed = 1.4;
        oy = Math.sin(t * speed + col * 0.4) * amp;
      } else if (formationType === 2) {
        const amp = 22;
        const speed = 1.2;
        ox = Math.sin(t * speed + row * 0.6) * amp;
      }

      return [ox, oy];
    }

    function tryStartDive(now) {
      if (level < 2) return;

      const interval = Math.max(1200, 3200 - level * 250);
      if (now - lastDiveTime < interval) return;

      const candidates = enemies.filter(e => !e.isDiving);
      if (!candidates.length) return;

      const e = candidates[Math.floor(Math.random() * candidates.length)];
      e.isDiving = true;

      const targetX = player.x + player.w / 2;
      const targetY = player.y + player.h / 2;

      const dx = targetX - e.x;
      const dy = targetY - e.y;

      const steps = 60;
      let vx = dx / steps;
      let vy = dy / steps;

      vx *= 0.75;
      vy *= 0.75;

      e.vx = vx;
      e.vy = vy;
      e.diveSpeedY = (0.10 + Math.random() * 0.05) * 0.75;

      lastDiveTime = now;
    }

    function spawnPowerup(x, y) {
      const overallChance = 0.12;
      if (Math.random() > overallChance) return;

      let type;
      const r = Math.random();
      if (r < 0.2) type = "rapid";
      else if (r < 0.4) type = "double";
      else if (r < 0.55) type = "shield";
      else if (r < 0.7) type = "pierce";
      else if (r < 0.85) type = "spread";
      else if (r < 0.95) type = "score";
      else type = "life";

      powerups.push({
        x: x + 18,
        y,
        w: 16,
        h: 16,
        dy: 1.2,
        type,
      });
    }

    function applyPowerup(type, now) {
      if (type === "rapid") {
        upgrades.rapidUntil = now + 8000;
        addPopup("Power-Up: Rapid Fire", "Significantly higher rate of fire.", 1800);
      } else if (type === "double") {
        upgrades.doubleUntil = now + 8000;
        addPopup("Power-Up: Double Shot", "Two shots at once.", 1800);
      } else if (type === "shield") {
        upgrades.shieldUntil = now + 10000;
        addPopup("Power-Up: Shield", "Blocks one incoming hit.", 1800);
      } else if (type === "pierce") {
        upgrades.pierceUntil = now + 8000;
        addPopup("Power-Up: Piercing Shot", "Bullets pierce through enemies.", 1800);
      } else if (type === "spread") {
        upgrades.spreadUntil = now + 8000;
        addPopup("Power-Up: Spread Shot", "Triple spread fire.", 1800);
      } else if (type === "score") {
        upgrades.scoreMultUntil = now + 10000;
        addPopup("Power-Up: Score Boost", "Double points for enemy kills.", 1800);
      } else if (type === "life") {
        if (player.lives < 8) {
          player.lives++;
          addPopup("Extra Life", "One additional life.", 1800);
        } else {
          score += 50;
          addPopup("Bonus Score", "+50 points instead of a life.", 1800);
        }
      }
      playSound("powerup");
    }

    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 0.5;
        particles.push({
          x,
          y,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          life: 600,
          age: 0,
          color,
        });
      }
    }

    let lastPlayerShotTime = 0;
    const baseShootCooldown = 230;

    function getPlayerShootCooldown(now) {
      if (now < upgrades.rapidUntil) return baseShootCooldown * 0.4;
      return baseShootCooldown;
    }

    function shootPlayer() {
      const now = performance.now();
      const cooldown = getPlayerShootCooldown(now);
      if (now - lastPlayerShotTime < cooldown) return;

      const doubleShot = now < upgrades.doubleUntil;
      const spreadShot = now < upgrades.spreadUntil;

      player.shootingUntil = now + 150;

      const bulletWidth = 4;
      const bulletHeight = 16;
      const baseX = player.x + player.w / 2 - bulletWidth / 2;
      const startY = player.y - 6;

      if (spreadShot) {
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: 0,    dy: -6 });
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: -1.8, dy: -5.3 });
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: 1.8,  dy: -5.3 });
      } else if (doubleShot) {
        bullets.push({ x: player.x + 8,             y: startY, w: bulletWidth, h: bulletHeight, dx: 0, dy: -6 });
        bullets.push({ x: player.x + player.w - 12, y: startY, w: bulletWidth, h: bulletHeight, dx: 0, dy: -6 });
      } else {
        bullets.push({ x: baseX, y: startY, w: bulletWidth, h: bulletHeight, dx: 0, dy: -6 });
      }

      weaponHeat = Math.min(1, weaponHeat + (spreadShot ? 0.25 : doubleShot ? 0.2 : 0.15));

      lastPlayerShotTime = now;
      playSound("laser");
    }

    function enemyShoot() {
      if (enemies.length === 0) return;
      const now = performance.now();
      if (now - lastEnemyShotTime < enemyShootInterval) return;

      const bottomEnemiesByCol = {};
      for (const e of enemies) {
        const colKey = e.col;
        if (!bottomEnemiesByCol[colKey] || bottomEnemiesByCol[colKey].y < e.y) {
          bottomEnemiesByCol[colKey] = e;
        }
      }
      const bottomList = Object.values(bottomEnemiesByCol);
      const shooter = bottomList[Math.floor(Math.random() * bottomList.length)];
      if (!shooter) return;

      enemyBullets.push({
        x: shooter.x + shooter.w / 2 - 2,
        y: shooter.y + shooter.h,
        w: 4,
        h: 16,
        dx: 0,
        dy: 3 + level * 0.3,
      });

      lastEnemyShotTime = now;
    }

    function startNewGame() {
      score = 0;
      level = 1;
      player.lives = 3;
      player.x = W / 2 - player.w / 2;
      bullets.length = 0;
      enemyBullets.length = 0;
      particles.length = 0;
      powerups.length = 0;
      popups.length = 0;
      upgrades.rapidUntil = 0;
      upgrades.doubleUntil = 0;
      upgrades.shieldUntil = 0;
      upgrades.pierceUntil = 0;
      upgrades.spreadUntil = 0;
      upgrades.scoreMultUntil = 0;
      comboCount = 0;
      comboTimer = 0;
      weaponHeat = 0;
      initEnemiesForLevel();
      lastEnemyMoveTime = 0;
      lastEnemyShotTime = 0;
      lastTime = 0;
      state = GAME_STATE.PLAYING;
      showLevelPopup();
      startBackgroundMusic();
    }

    function startNextLevel() {
      const completedLevel = level; // level just cleared

      level++;
      bullets.length = 0;
      enemyBullets.length = 0;
      particles.length = 0;
      powerups.length = 0;
      comboCount = 0;
      comboTimer = 0;
      weaponHeat = 0;
      initEnemiesForLevel();
      lastEnemyMoveTime = 0;
      lastEnemyShotTime = 0;
      showLevelPopup();
      showHannityNews(completedLevel);
    }

    function gameOver() {
      state = GAME_STATE.GAMEOVER;
      playSound("explosion");
      addPopup("Capitol lost.", "Bureaucracy was stronger this time.", 2600);
      if (score > highScore) {
        highScore = score;
        try {
          localStorage.setItem("pixelInvadersHighScore", String(highScore));
        } catch (_) {}
      }
    }

    function registerKill(now) {
      if (comboTimer > 0) {
        comboCount++;
      } else {
        comboCount = 1;
      }
      comboTimer = COMBO_WINDOW;
    }

    let lastTime = 0;

    function update(dt) {
      if (state !== GAME_STATE.PLAYING) {
        updatePopups(dt);
        return;
      }

      const now = performance.now();

      if (comboTimer > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) {
          comboTimer = 0;
          comboCount = 0;
        }
      }

      if (weaponHeat > 0) {
        weaponHeat -= dt * 0.0003;
        if (weaponHeat < 0) weaponHeat = 0;
      }

      if (keys["ArrowLeft"])  player.x -= player.speed;
      if (keys["ArrowRight"]) player.x += player.speed;
      if (player.x < 16) player.x = 16;
      if (player.x + player.w > W - 16) player.x = W - 16 - player.w;

      for (const b of bullets) {
        b.x += b.dx || 0;
        b.y += b.dy;
      }
      for (const eb of enemyBullets) {
        eb.x += eb.dx || 0;
        eb.y += eb.dy;
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (b.y + b.h < 0 || b.x < -50 || b.x > W + 50) bullets.splice(i, 1);
      }
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        if (eb.y > H + 50) enemyBullets.splice(i, 1);
      }

      const moveNow = now;
      if (moveNow - lastEnemyMoveTime > 20) {
        formationOffsetX += enemyDx * formationDir;

        let minX = Infinity;
        let maxX = -Infinity;
        const t = moveNow / 1000;

        for (const e of enemies) {
          if (e.isDiving) continue;
          const [ox] = getFormationOffsets(e.row, e.col, t);
          const ex = e.baseX + formationOffsetX + ox;
          if (ex < minX) minX = ex;
          if (ex + e.w > maxX) maxX = ex + e.w;
        }

        if (minX !== Infinity && (minX <= 16 || maxX >= W - 16)) {
          formationDir *= -1;
          formationOffsetX += enemyDx * formationDir;
          formationOffsetY += enemyStepDown;

          let maxY = -Infinity;
          for (const e of enemies) {
            if (e.isDiving) continue;
            const t2 = moveNow / 1000;
            const [ox2, oy2] = getFormationOffsets(e.row, e.col, t2);
            const ey = e.baseY + formationOffsetY + oy2;
            if (ey + e.h > maxY) maxY = ey + e.h;
          }
          if (maxY >= player.y) {
            gameOver();
          }
        }

        lastEnemyMoveTime = moveNow;
      }

      const t = now / 1000;
      for (const e of enemies) {
        if (e.isDiving) {
          e.vy += e.diveSpeedY;
          e.x += e.vx;
          e.y += e.vy;
        } else {
          const [ox, oy] = getFormationOffsets(e.row, e.col, t);
          e.x = e.baseX + formationOffsetX + ox;
          e.y = e.baseY + formationOffsetY + oy;
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.isDiving) continue;
        if (
          e.x < player.x + player.w &&
          e.x + e.w > player.x &&
          e.y < player.y + player.h &&
          e.y + e.h > player.y
        ) {
          enemies.splice(i, 1);

          if (now < upgrades.shieldUntil) {
            upgrades.shieldUntil = 0;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#80deea");
            playSound("shieldBreak");
            continue;
          }

          if (now > player.invincibleUntil) {
            player.lives--;
            player.invincibleUntil = now + 1500;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffb74d");
            playSound("hit");
            if (player.lives <= 0) {
              gameOver();
            }
          }
        }
      }

      tryStartDive(now);
      enemyShoot();

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        let hit = false;

        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (
            b.x < e.x + e.w &&
            b.x + b.w > e.x &&
            b.y < e.y + e.h &&
            b.y + b.h > e.y
          ) {
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#64b5f6");
            spawnPowerup(e.x, e.y);
            enemies.splice(j, 1);

            registerKill(now);

            const mult = now < upgrades.scoreMultUntil ? 2 : 1;
            score += 10 * mult;

            playSound("explosion");
            hit = true;

            const piercing = now < upgrades.pierceUntil;
            if (!piercing) bullets.splice(i, 1);
            break;
          }
        }
        if (hit && i >= bullets.length) continue;
      }

      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        if (
          eb.x < player.x + player.w &&
          eb.x + eb.w > player.x &&
          eb.y < player.y + player.h &&
          eb.y + eb.h > player.y
        ) {
          enemyBullets.splice(i, 1);

          if (now < upgrades.shieldUntil) {
            upgrades.shieldUntil = 0;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#80deea");
            playSound("shieldBreak");
            continue;
          }

          if (now > player.invincibleUntil) {
            player.lives--;
            player.invincibleUntil = now + 1500;
            spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffb74d");
            playSound("hit");
            if (player.lives <= 0) gameOver();
          }
        }
      }

      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += p.dy;
        if (p.y > H + 20) {
          powerups.splice(i, 1);
          continue;
        }

        if (
          p.x < player.x + player.w &&
          p.x + p.w > player.x &&
          p.y < player.y + player.h &&
          p.y + p.h > player.y
        ) {
          applyPowerup(p.type, now);
          powerups.splice(i, 1);
        }
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx;
        p.y += p.dy;
        p.age += dt;
        p.dy += 0.02;
        if (p.age > p.life) particles.splice(i, 1);
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (e.isDiving && (e.y > H + 80 || e.x < -80 || e.x > W + 80)) {
          enemies.splice(i, 1);
        }
      }

      updatePopups(dt);

      if (enemies.length === 0 && state === GAME_STATE.PLAYING) {
        startNextLevel();
      }
    }

    function updatePopups(dt) {
      for (let i = popups.length - 1; i >= 0; i--) {
        popups[i].age += dt;
        if (popups[i].age > popups[i].life) popups.splice(i, 1);
      }
    }

    function drawBackground() {
      ctx.clearRect(0, 0, W, H);
    }

    function drawPixelRect(x, y, w, h, color, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillRect(Math.round(x), Math.round(y), w, h);
      ctx.restore();
    }

    function drawPanel(x, y, w, h, alpha = 0.6) {
      ctx.save();
      ctx.fillStyle = `rgba(0,0,0,${alpha})`;
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = "rgba(255,255,255,0.3)";
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
      ctx.restore();
    }

    function drawPlayer() {
      const now = performance.now();
      const flashing = now < player.invincibleUntil && Math.floor(now / 100) % 2 === 0;

      if (now < upgrades.shieldUntil) {
        drawPixelRect(player.x - 6, player.y - 6, player.w + 12, player.h + 12, "#80deea", 0.25);
      }

      if (flashing) return;

      const isShooting = now < player.shootingUntil;
      const img = isShooting ? playerImgShoot : playerImgNormal;

      if (img && img.complete) {
        ctx.drawImage(img, Math.round(player.x), Math.round(player.y), player.w, player.h);
      } else {
        drawPixelRect(player.x, player.y + 10, player.w, player.h - 10, "#b71c1c");
        drawPixelRect(player.x + 12, player.y, 28, 10, "#f5d7b3");
        drawPixelRect(player.x + player.w / 2 - 2, player.y + 12, 4, 10, "#ff5252");
      }
    }

    function drawEnemies() {
      for (const e of enemies) {
        const img = enemyImages[e.spriteIndex] || null;
        if (img && img.complete) {
          ctx.drawImage(img, Math.round(e.x), Math.round(e.y), e.w, e.h);
        } else {
          drawPixelRect(e.x, e.y + 12, e.w, e.h - 12, "#1976d2");
          drawPixelRect(e.x + 8, e.y, e.w - 16, 12, "#ffeb3b");
        }
      }
    }

    function drawBullets() {
      for (const b of bullets) drawPixelRect(b.x, b.y, b.w, b.h, "#fff");
    }

    function drawEnemyBullets() {
      for (const eb of enemyBullets) drawPixelRect(eb.x, eb.y, eb.w, eb.h, "#ffeb3b");
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = 1 - p.age / p.life;
        drawPixelRect(p.x, p.y, 3, 3, p.color, alpha);
      }
    }

    function drawPowerups() {
      for (const p of powerups) {
        let color = "#fff";
        if (p.type === "rapid") color = "#ff9800";
        else if (p.type === "double") color = "#ab47bc";
        else if (p.type === "shield") color = "#80deea";
        else if (p.type === "pierce") color = "#8bc34a";
        else if (p.type === "spread") color = "#ec407a";
        else if (p.type === "score") color = "#ffc107";
        else if (p.type === "life") color = "#ef5350";
        drawPixelRect(p.x, p.y, p.w, p.h, color);
      }
    }

    function drawHUD() {
      const now = performance.now();

      drawPixelRect(0, 0, W, HUD_BAR_HEIGHT, "#000", 0.55);
      drawPixelRect(0, HUD_BAR_HEIGHT, W, 2, "#ffffff", 0.1);

      ctx.font = "16px monospace";

      // SCORE
      const scorePanelX = 10;
      const scorePanelY = 10;
      const scorePanelW = 200;
      const scorePanelH = 44;
      drawPanel(scorePanelX, scorePanelY, scorePanelW, scorePanelH, 0.7);

      ctx.save();
      ctx.textAlign = "left";
      ctx.fillStyle = "#9fa8da";
      ctx.fillText("SCORE", scorePanelX + 10, scorePanelY + 18);
      ctx.fillStyle = "#ffeb3b";
      ctx.fillText(String(score).padStart(4, " "), scorePanelX + 10, scorePanelY + 34);

      const comboText = "COMBO x" + (comboCount > 0 ? comboCount : 1);
      ctx.fillStyle = comboCount > 1 ? "#ff8a65" : "#555";
      ctx.fillText(comboText, scorePanelX + 110, scorePanelY + 34);

      const heatX = scorePanelX + 10;
      const heatY = scorePanelY + 36;
      const heatW = scorePanelW - 20;
      const heatH = 6;
      drawPixelRect(heatX, heatY, heatW, heatH, "#000", 0.6);
      const heatColor =
        weaponHeat > 0.7 ? "#ef5350" :
        weaponHeat > 0.35 ? "#ffb74d" : "#81c784";
      if (weaponHeat > 0) {
        drawPixelRect(
          heatX + 1,
          heatY + 1,
          (heatW - 2) * weaponHeat,
          heatH - 2,
          heatColor,
          1
        );
      }
      ctx.restore();

      // LIVES
      const livesPanelX = 230;
      const livesPanelY = 10;
      const livesPanelW = 260;
      const livesPanelH = 44;
      drawPanel(livesPanelX, livesPanelY, livesPanelW, livesPanelH, 0.7);

      ctx.save();
      ctx.textAlign = "left";
      ctx.fillStyle = "#ff8a80";
      ctx.fillText("LIVES", livesPanelX + 10, livesPanelY + 18);

      for (let i = 0; i < player.lives; i++) {
        const x = livesPanelX + 80 + i * 26;
        const y = livesPanelY + 10;
        const size = 22;
        if (heartImg.complete && heartImg.naturalWidth > 0) {
          ctx.drawImage(heartImg, x, y, size, size);
        } else {
          drawPixelRect(x + 4, y + 8, 12, 12, "#e53935");
        }
      }
      ctx.restore();

      // LEVEL + threat + progress
      const levelPanelX = 510;
      const levelPanelY = 10;
      const levelPanelW = 200;
      const levelPanelH = 44;
      drawPanel(levelPanelX, levelPanelY, levelPanelW, levelPanelH, 0.7);

      let divingCount = 0;
      let maxDiveY = 0;
      for (const e of enemies) {
        if (e.isDiving) {
          divingCount++;
          if (e.y > maxDiveY) maxDiveY = e.y;
        }
      }
      let threatLabel = "LOW";
      let threatColor = "#c5e1a5";
      if (divingCount >= 3 || maxDiveY > player.y - 80) {
        threatLabel = "HIGH";
        threatColor = "#ef5350";
      } else if (divingCount >= 1 || maxDiveY > player.y - 160) {
        threatLabel = "MED";
        threatColor = "#ffc107";
      }

      ctx.save();
      ctx.textAlign = "center";
      ctx.fillStyle = "#80cbc4";
      ctx.fillText("LEVEL", levelPanelX + levelPanelW / 2, levelPanelY + 18);
      ctx.fillStyle = "#ffffff";
      ctx.fillText(String(level), levelPanelX + levelPanelW / 2, levelPanelY + 34);

      ctx.textAlign = "right";
      ctx.fillStyle = threatColor;
      ctx.font = "12px monospace";
      ctx.fillText("THR " + threatLabel, levelPanelX + levelPanelW - 8, levelPanelY + 18);
      ctx.font = "16px monospace";
      ctx.restore();

      const barX = levelPanelX + 15;
      const barY = levelPanelY + 34;
      const barW = levelPanelW - 30;
      const barH = 6;
      const progress = totalEnemiesThisLevel > 0
        ? 1 - enemies.length / totalEnemiesThisLevel
        : 0;
      drawPixelRect(barX, barY, barW, barH, "#000", 0.5);
      if (progress > 0) {
        const progColor =
          progress < 0.33 ? "#8bc34a" :
          progress < 0.66 ? "#ffc107" : "#ef5350";
        drawPixelRect(barX + 1, barY + 1, (barW - 2) * progress, barH - 2, progColor, 1);
      }

      // HI / SOUND
      const hiPanelW = 200;
      const hiPanelX = W - hiPanelW - 10;
      const hiPanelY = 10;
      const hiPanelH = 44;
      drawPanel(hiPanelX, hiPanelY, hiPanelW, hiPanelH, 0.7);

      ctx.save();
      ctx.textAlign = "right";
      ctx.fillStyle = "#ffe082";
      ctx.fillText("HI " + String(highScore).padStart(4, " "), hiPanelX + hiPanelW - 10, hiPanelY + 18);
      ctx.fillStyle = muted ? "#ef5350" : "#c5e1a5";
      ctx.fillText(muted ? "MUTED" : "SOUND", hiPanelX + hiPanelW - 10, hiPanelY + 34);
      ctx.restore();

      // PWR
      const pwrPanelX = 10;
      const pwrPanelY = HUD_BAR_HEIGHT + 4;
      const pwrPanelW = 320;
      const pwrPanelH = 34;
      drawPanel(pwrPanelX, pwrPanelY, pwrPanelW, pwrPanelH, 0.7);

      ctx.save();
      ctx.textAlign = "left";
      ctx.fillStyle = "#b0bec5";
      ctx.fillText("PWR", pwrPanelX + 10, pwrPanelY + 20);

      const defs = [
        { key: "rapidUntil",  label: "R",  color: "#ff9800" },
        { key: "doubleUntil", label: "D",  color: "#ab47bc" },
        { key: "shieldUntil", label: "S",  color: "#80deea" },
        { key: "pierceUntil", label: "P",  color: "#8bc34a" },
        { key: "spreadUntil", label: "W",  color: "#ec407a" },
        { key: "scoreMultUntil", label: "$", color: "#ffc107" },
      ];

      defs.forEach((p, i) => {
        const active = now < upgrades[p.key];
        const cellX = pwrPanelX + 60 + i * 40;
        const cellY = pwrPanelY + 8;
        const cellW = 28;
        const cellH = 18;

        drawPixelRect(cellX, cellY, cellW, cellH, "#000", 0.7);
        drawPixelRect(
          cellX + 2,
          cellY + 2,
          cellW - 4,
          cellH - 6,
          active ? p.color : "#555",
          active ? 1 : 0.4
        );
        ctx.textAlign = "center";
        ctx.font = "11px monospace";
        ctx.fillStyle = active ? "#000" : "#ccc";
        ctx.fillText(p.label, cellX + cellW / 2, cellY + cellH - 4);
      });
      ctx.font = "16px monospace";
      ctx.restore();

      // Ticker
      if (tickerMessages.length) {
        ctx.save();
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = "13px monospace";
        ctx.fillText(tickerMessages[tickerIndex], W / 2, HUD_BAR_HEIGHT - 8);
        ctx.restore();
      }
    }

    function drawPopups() {
      if (!popups.length) return;
      const p = popups[0];

      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(W / 2 - 160, H / 2 - 50, 320, 100);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "20px monospace";
      ctx.fillText(p.title, W / 2, H / 2 - 10);

      if (p.subtitle) {
        ctx.font = "13px monospace";
        ctx.fillText(p.subtitle, W / 2, H / 2 + 18);
      }

      ctx.textAlign = "left";
      ctx.restore();
    }

    function drawMenu() {
      drawBackground();

      let logoW = 500;
      let logoH = 240;
      if (logoImg.complete && logoImg.naturalWidth > 0) {
        const aspect = logoImg.naturalWidth / logoImg.naturalHeight;
        logoH = logoW / aspect;
      }

      const logoX = W / 2 - logoW / 2;
      const logoY = H / 2 - logoH / 2 - 40;

      if (logoImg.complete && logoImg.naturalWidth > 0) {
        ctx.drawImage(logoImg, logoX, logoY, logoW, logoH);
      } else {
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.font = "32px monospace";
        ctx.fillText("CAPITOL DEFENDER", W / 2, H / 2);
      }

      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(W / 2 - 240, logoY + logoH + 30, 480, 70);

      ctx.fillStyle = "#fff";
      ctx.font = "20px monospace";
      ctx.textAlign = "center";
      ctx.fillText("Click the logo or press ENTER to start", W / 2, logoY + logoH + 58);
      ctx.font = "14px monospace";
      ctx.fillText("High Score: " + highScore, W / 2, logoY + logoH + 80);

      ctx.textAlign = "left";
    }

    function drawGame() {
      drawBackground();
      drawEnemies();
      drawEnemyBullets();
      drawBullets();
      drawPowerups();
      drawPlayer();
      drawParticles();
      drawHUD();
      drawPopups();
    }

    function drawGameOverScreen() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(W / 2 - 180, H / 2 - 60, 360, 120);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "28px monospace";
      ctx.fillText("GAME OVER", W / 2, H / 2 - 10);

      ctx.font = "18px monospace";
      ctx.fillText("Score: " + score, W / 2, H / 2 + 15);
      ctx.fillText("High Score: " + highScore, W / 2, H / 2 + 35);
      ctx.fillText("Press R or Enter", W / 2, H / 2 + 55);

      ctx.textAlign = "left";
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      updateTicker(dt);

      if (state === GAME_STATE.MENU) {
        drawMenu();
        updatePopups(dt);
      } else if (state === GAME_STATE.PLAYING) {
        update(dt);
        drawGame();
      } else if (state === GAME_STATE.GAMEOVER) {
        updatePopups(dt);
        drawGame();
        drawGameOverScreen();
      }

      requestAnimationFrame(loop);
    }

    initEnemiesForLevel();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
